(libload "ros/ros")

;; Add include paths for roscpp.
(setq c-include-path (cons (concat (rospath "roscpp")
                           "/include") c-include-path))
(setq c-include-path (cons (concat (rospath "rostime")
                           "/include") c-include-path))
(setq c-include-path (cons (concat (rospath "rosconsole")
                           "/include") c-include-path))
(setq c-include-path (cons (concat (rospath "std_msgs")
                           "/include") c-include-path))
(setq c-include-path (cons (concat (rospath "cpp_common")
                           "/include") c-include-path))
(setq c-include-path (cons (concat (rospath "roscpp_serialization")
                           "/include") c-include-path))
(setq c-include-path (cons (concat (rospath "roscpp_traits")
                           "/include") c-include-path))
(setq c-include-path (cons (concat (rospath "xmlrpcpp")
                           "/src") c-include-path))
;; Include paths for messages.
(setq c-include-path (cons (concat (rospath "std_msgs")
                           "/msg_gen/cpp/include") c-include-path))
(setq c-include-path (cons (concat (rospath "sensor_msgs")
                           "/msg_gen/cpp/include") c-include-path))
(setq c-include-path (cons (concat (rospath "geometry_msgs")
                           "/msg_gen/cpp/include") c-include-path))
(setq c-include-path (cons (concat (rospath "nav_msgs")
                           "/msg_gen/cpp/include") c-include-path))

#? turtlebot
;; Control interface for the ROS turtlebot.
(defclass turtlebot object
  ((-gptr- "RosClient*") client)
  ;; Depth image.
  ((-idx2- (-short-)) camera-depth-image-raw)
  ;; Odometry.
  ((-idx1- (-double-)) odom-pose-position)
  ((-idx1- (-double-)) odom-pose-orientation)
  ((-idx1- (-double-)) odom-pose-covariance)
  ((-idx1- (-double-)) odom-twist-linear)
  ((-idx1- (-double-)) odom-twist-angular)
  ((-idx1- (-double-)) odom-twist-covariance)
  ;; Depth points (XYZ).
  ((-idx2- (-float-)) camera-depth-points)
  )

#? (new turtlebot)
(defmethod turtlebot turtlebot ()
  (setq client (to-gptr #{ new RosClient() #}))
  ;; Depth image.
  (setq camera-depth-image-raw (short-matrix 480 640))
  ;; Odometry.
  (setq odom-pose-position (double-matrix 3))
  (setq odom-pose-orientation (double-matrix 4))
  (setq odom-pose-covariance (double-matrix 36))
  (setq odom-twist-linear (double-matrix 3))
  (setq odom-twist-angular (double-matrix 3))
  (setq odom-twist-covariance (double-matrix 36))
  ;; Depth points (XYZ).
  (setq camera-depth-points (float-matrix (* 480 640) 3))
  ()
  )

#? (delete <turtlebot>)
(defmethod turtlebot -destructor ()
  #{ delete $client; #}
  ()
  )

#? (==> <turtlebot> start-sub-camera-depth-image-raw)
;; Start the camera depth image_raw subscriber.
(defmethod turtlebot start-sub-camera-depth-image-raw ()
  (to-int #{ $client->StartSubscriber<CameraDepthImageRawSubscriber>() #})
  )

#? (==> <turtlebot> update-camera-depth-image-raw)
;; Update the camera depth image_raw subscriber.
(defmethod turtlebot update-camera-depth-image-raw ()
  (to-int #{
     $client->Update<CameraDepthImageRawSubscriber>(IDX_PTR($camera_depth_image_raw,
                                                            int_least16_t))
     #})
  )

#? (==> <turtlebot> start-sub-odom)
;; Start the odometry subscriber.
(defmethod turtlebot start-sub-odom ()
  (to-int #{ $client->StartSubscriber<OdomSubscriber>() #})
  )

#? (==> <turtlebot> update-odom)
;; Update the odometry subscriber.
(defmethod turtlebot update-odom ()
  (to-int #{
     $client->Update<OdomSubscriber>(
       &OdomSubscriber::lush_convert_type(IDX_PTR($odom_pose_position, double),
                                          IDX_PTR($odom_pose_orientation, double),
                                          IDX_PTR($odom_pose_covariance, double),
                                          IDX_PTR($odom_twist_linear, double),
                                          IDX_PTR($odom_twist_angular, double),
                                          IDX_PTR($odom_twist_covariance, double)))
     #})
  )

#? (==> <turtlebot> start-sub-camera-depth-points)
;; Start the camera depth points subscriber.
(defmethod turtlebot start-sub-camera-depth-points ()
  (to-int #{ $client->StartSubscriber<CameraDepthPointsSubscriber>() #})
  )

#? (==> <turtlebot> update-camera-depth-points)
;; Update the camera depth points subscriber.
(defmethod turtlebot update-camera-depth-points ()
  (let ((num-points [i 0]) (res 0))
    ;; Fetch point data then resize the structure for this frame.
    (setq res
       (to-int #{
         $client->Update<CameraDepthPointsSubscriber>(
           &CameraDepthPointsSubscriber::lush_convert_type(IDX_PTR($camera_depth_points, float),
                                                           IDX_PTR($num_points, int)))
         #})
     )
    (idx-changedim camera-depth-points 0 (num-points 0))
    res
    )
  )

#? (==> <turtlebot> start-pub-cmd-vel)
;; Start the camera cmd_vel publisher.
(defmethod turtlebot start-pub-cmd-vel ()
  (to-int #{ $client->StartPublisher<CmdVelPublisher>() #})
  )

#? (==> <turtlebot> publish_cmd_vel <linear> <angular>)
;; Publish the cmd_vel Twist message..
(defmethod turtlebot publish_cmd_vel (linear angular)
  ((-idx1- (-double-)) linear)
  ((-idx1- (-double-)) angular)
  #{
    ;
    $client->Publish<CmdVelPublisher>(
      CmdVelPublisher::lush_convert_type(IDX_PTR($linear, double),
                                         IDX_PTR($angular, double)));
  #}
  ()
  )

(dhc-make-with-c++
  ()
  `(,(concat (rospath "roscpp") "/lib/libros.so"))
  #{
    #include "ros/ros.h"
    #include "ros/exceptions.h"
    #include "sensor_msgs/Image.h"
    #include "geometry_msgs/Twist.h"
    #include "nav_msgs/Odometry.h"
    #include "sensor_msgs/PointCloud2.h"
    #include "sensor_msgs/Imu.h"
    #include "boost/scoped_ptr.hpp"
    #include <exception>
    #include <string>
    #include <iostream>
    #include <stdint.h>
    #include <cstring>
    #include <cmath>

    // Forward declaration.
    template <typename RosLushSubscriberTraits> class RosSubscriber;
    template <typename RosLushPublisherTraits> class RosPublisher;

    /// <summary> OpenNI camera depth raw subscriber. </summary>
    struct RosLushCameraDepthImageRaw
    {
      enum { queue_size = 1, };
      typedef sensor_msgs::Image msg_type;
      typedef int_least16_t lush_convert_type;
      inline static const char* TopicStr()
      {
        return "camera/depth/image_raw";
      }
      inline static void CopyMsgData(const msg_type::ConstPtr& msg,
                                     lush_convert_type* data)
      {
        const int32_t dataSize = static_cast<int32_t>(msg->data.size());
        memcpy(data, &msg->data[0], dataSize);
      }
    };
    typedef RosSubscriber<RosLushCameraDepthImageRaw> CameraDepthImageRawSubscriber;

    template <typename Vector3>
    inline void CopyVector3(const Vector3& src, double* dst)
    {
      dst[0] = src.x; dst[1] = src.y; dst[2] = src.z;
    }

    template <typename Vector4>
    inline void CopyVector4(const Vector4& src, double* dst)
    {
      dst[0] = src.x; dst[1] = src.y; dst[2] = src.z; dst[3] = src.w;
    }

    /// <summary> Turtlebot odometry subscriber. </summary>
    struct RosLushOdom
    {
      struct OdomData
      {
        OdomData(double* p_pos, double* p_orien, double* p_cov,
                 double* t_lin, double* t_ang, double* t_cov)
          : pose_position(p_pos), pose_orientation(p_orien), pose_covariance(p_cov),
            twist_linear(t_lin), twist_angular(t_ang), twist_covariance(t_cov)
        {}
        double *pose_position, *pose_orientation, *pose_covariance;
        double *twist_linear, *twist_angular, *twist_covariance;
      };
      enum { queue_size = 5, };
      typedef nav_msgs::Odometry msg_type;
      typedef OdomData lush_convert_type;
      inline static const char* TopicStr()
      {
        return "odom";
      }
      inline static void CopyMsgData(const msg_type::ConstPtr& msg,
                                     lush_convert_type* data)
      {
        CopyVector3(msg->twist.twist.linear, data->twist_linear);
        CopyVector3(msg->twist.twist.angular, data->twist_angular);
        memcpy(data->twist_covariance, &msg->twist.covariance[0],
               msg->twist.covariance.size() * sizeof(msg->twist.covariance[0]));
        CopyVector3(msg->pose.pose.position, data->pose_position);
        CopyVector4(msg->pose.pose.orientation, data->pose_orientation);
        memcpy(data->pose_covariance, &msg->pose.covariance[0],
               msg->pose.covariance.size() * sizeof(msg->pose.covariance[0]));
      }
    };
    typedef RosSubscriber<RosLushOdom> OdomSubscriber;

    /// <summary> Point cloud subscriber. </summary>
    struct RosLushCameraDepthPoints
    {
      struct CloudData
      {
        CloudData(float* data_, int* numPoints_)
          : data(data_),
            numPoints(numPoints_)
        {}
        float* data;
        int* numPoints;
      };
      enum { queue_size = 1, };
      typedef sensor_msgs::PointCloud2 msg_type;
      typedef CloudData lush_convert_type;
      inline static const char* TopicStr()
      {
        return "camera/depth/points";
      }
      inline static void CopyMsgData(const msg_type::ConstPtr& msg,
                                     lush_convert_type* data)
      {
        enum { Float32XYZPointSize = sizeof(float) * 3, };
        // Collect parameters.
        uint8_t* dataDst = reinterpret_cast<uint8_t*>(data->data);
        int& numPoints = *data->numPoints;
        numPoints = 0;
        // Copy all of the points (XYZ) to the data array.
        const int pointStep = msg->point_step;
        const int dataLength = msg->height * msg->row_step;
        const uint8_t* dataSrc = &msg->data[0];
        const uint8_t* const dataSrcEnd = dataSrc + dataLength;
        for (; dataSrc < dataSrcEnd; dataSrc += pointStep)
        {
          // Ignore bad points.
          if (!std::isnan(*reinterpret_cast<const float*>(dataSrc)))
          {
            memcpy(dataDst, dataSrc, Float32XYZPointSize);
            dataDst += Float32XYZPointSize;
            ++numPoints;
          }
        }
      }
    };
    typedef RosSubscriber<RosLushCameraDepthPoints> CameraDepthPointsSubscriber;

    /// <summary> Twist cmd_vel message publisher. </summary>
    struct RosLushCmdVel
    {
      struct TwistData
      {
        TwistData(double* linear_, double* angular_)
         : linear(linear_),
           angular(angular_)
        {}
        double* linear;
        double* angular;
      };
      enum { queue_size = 5, };
      typedef geometry_msgs::Twist msg_type;
      typedef TwistData lush_convert_type;
      inline static const char* TopicStr()
      {
        return "/cmd_vel";
      }
      inline static void CopyMsgData(const lush_convert_type& data,
                                     msg_type* msg)
      {
        msg->linear.x = data.linear[0];
        msg->linear.y = data.linear[1];
        msg->linear.z = data.linear[2];
        msg->angular.x = data.angular[0];
        msg->angular.y = data.angular[1];
        msg->angular.z = data.angular[2];
      }
    };
    typedef RosPublisher<RosLushCmdVel> CmdVelPublisher;

    /// <summary> Generic ROS subscriber logic. </summary>
    template <typename RosLushSubscriberTraits>
    class RosSubscriber
    {
    public:
      typedef typename RosLushSubscriberTraits::msg_type msg_type;
      typedef typename RosLushSubscriberTraits::lush_convert_type lush_convert_type;

      RosSubscriber()
      : m_subscriber(),
        m_frId(-1),
        m_lastFrIdUpdated(-1),
        m_mostRecent()
      {}

      virtual ~RosSubscriber()
      {}

      /// <summary> Callback for subscription. </summary>
      void Callback(const typename msg_type::ConstPtr& msg)
      {
        m_mostRecent = msg;
        ++m_frId;
      }

      /// <summary> Start subscriber. </summary>
      /// <returns> Zero on success, otherwise failure.. </returns>
      int StartSubscriber(ros::NodeHandle* nodeHandle)
      {
        assert(nodeHandle);
        try
        {
          m_subscriber = nodeHandle->subscribe(RosLushSubscriberTraits::TopicStr(),
                                               RosLushSubscriberTraits::queue_size,
                                               &RosSubscriber::Callback,
                                               this);
          std::cout << "StartSubscriber() : subscribed to "
                       "'" << RosLushSubscriberTraits::TopicStr() << "'"
                    << std::endl;
          return 0;
        }
        catch (std::exception& e)
        {
          std::cerr << "StartSubscriber() : error subscribing to "
                       "'" << RosLushSubscriberTraits::TopicStr() << "'"
                    << std::endl;
          return 1;
        }
      }

      /// <summary> Update subscriber. </summary>
      /// <returns> Non-negative frame id on success. </returns>
      int Update(lush_convert_type* data)
      {
        ros::spinOnce();
        if (m_lastFrIdUpdated < m_frId)
        {
          // Copy data then release message.
          RosLushSubscriberTraits::CopyMsgData(m_mostRecent, data);
          m_mostRecent.reset();
          m_lastFrIdUpdated = m_frId;
          return m_lastFrIdUpdated;
        }
        else
        {
          return -1;
        }
      }

    private:
      ros::Subscriber m_subscriber;
      int32_t m_frId;
      int32_t m_lastFrIdUpdated;
      typename msg_type::ConstPtr m_mostRecent;
    };

    /// <summary> Generic ROS publisher logic. </summary>
    template <typename RosLushPublisherTraits>
    class RosPublisher
    {
    public:
      typedef typename RosLushPublisherTraits::msg_type msg_type;
      typedef typename RosLushPublisherTraits::lush_convert_type lush_convert_type;

      RosPublisher()
      : m_publisher(),
        m_msg()
      {}

      virtual ~RosPublisher()
      {}

      /// <summary> Start publishing. </summary>
      /// <returns> Zero on success, otherwise failure.. </returns>
      int StartPublisher(ros::NodeHandle* nodeHandle)
      {
        assert(nodeHandle);
        try
        {
          const std::string topicStr(RosLushPublisherTraits::TopicStr());
          const uint32_t queueSize = RosLushPublisherTraits::queue_size;
          m_publisher = nodeHandle->advertise<msg_type>(topicStr, queueSize);
          std::cout << "StartPublisher() : publishing to "
                       "'" << RosLushPublisherTraits::TopicStr() << "'"
                    << std::endl;
          return 0;
        }
        catch (std::exception& e)
        {
          std::cerr << "StartPublisher() : error publishing to "
                       "'" << RosLushPublisherTraits::TopicStr() << "'"
                    << std::endl;
          return 1;
        }
      }

      /// <summary> Publish a message. </summary>
      void Publish(const lush_convert_type& data)
      {
        // Copy data then publish.
        // TODO(reissb) -- 20120306 -- To use the shared_ptr API of publish(),
        //   we will require a memory pool of messages. This only affects
        //   intra-process operation between nodes.
        RosLushPublisherTraits::CopyMsgData(data, &m_msg);
        m_publisher.publish(m_msg);
      }

    private:
      ros::Publisher m_publisher;
      msg_type m_msg;
    };

    /// <summary> The ROS client for turtlebot. </summary>
    /// <remarks>
    ///   <para> Inherit from subscriber/publisher types to add
    ///     stream services.
    ///   </para>
    /// </remarks>
    class RosClient
      : // Subscribers.
        public CameraDepthImageRawSubscriber,
        public OdomSubscriber,
        public CameraDepthPointsSubscriber,

        // Publishers
        public CmdVelPublisher
    {
    public:
      RosClient()
      : m_nodeHandle(NULL)
      {
        // Init ROS.
        {
          ros::VP_string remappings;
          ros::init(remappings, std::string("listener"),
                    ros::init_options::AnonymousName);
        }
        std::cout << "RosClient() : initialized ros" << std::endl;
        // Start the node.
        m_nodeHandle.reset(new ros::NodeHandle());
        std::cout << "RosClient() : started node " << m_nodeHandle
                  << std::endl;
      }

      /// <summary> Start a ROS subscriber. </summary>
      template <typename SubscriberType>
      inline int StartSubscriber()
      {
        SubscriberType* subscriber = static_cast<SubscriberType*>(this);
        return subscriber->StartSubscriber(m_nodeHandle.get());
      }

      /// <summary> Update a ROS subscriber. </summary>
      template <typename SubscriberType>
      inline int Update(typename SubscriberType::lush_convert_type* data)
      {
        SubscriberType* subscriber = static_cast<SubscriberType*>(this);
        return subscriber->Update(data);
      }

      /// <summary> Start a ROS publisher. </summary>
      template <typename PublisherType>
      inline int StartPublisher()
      {
        PublisherType* publisher = static_cast<PublisherType*>(this);
        return publisher->StartPublisher(m_nodeHandle.get());
      }

      /// <summary> Publish to a ROS publisher. </summary>
      template <typename PublisherType>
      inline void Publish(const typename PublisherType::lush_convert_type& data)
      {
        PublisherType* publisher = static_cast<PublisherType*>(this);
        publisher->Publish(data);
      }

    private:
      // Disable copy and assign.
      RosClient(const RosClient&);
      RosClient& operator=(const RosClient&);

      /// <summary> The ROS node maintains the connections. </summary>
      boost::scoped_ptr<ros::NodeHandle> m_nodeHandle;
    };
  #}
  (turtlebot
    turtlebot
    -destructor
    ;; Depth image raw.
    start-sub-camera-depth-image-raw
    update-camera-depth-image-raw
    ;; Odom.
    start-sub-odom
    update-odom
    ;; Depth points (XYZ).
    start-sub-camera-depth-points
    update-camera-depth-points
    ;; Publish cmd_vel.
    start-pub-cmd-vel
    publish_cmd_vel
    )
  )

#? turtlebot-test
;; Create a graphics window and show the raw depth data.
(de turtlebot-test ()
  (let* ((tb (new turtlebot)))
    (==> tb start-sub-camera-depth-image-raw)
    (new-window)
    (for (i 0 100)
      (==> tb update-camera-depth-image-raw)
      (gray-draw-matrix 0 0 :tb:camera-depth-image-raw 0 1023 1 1)
      )
    )
  )

