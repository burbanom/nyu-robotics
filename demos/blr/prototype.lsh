;; Prototype file for demos/blr.
(libload "feature-map")
(libload "turtlebot/turtlebot")
(libload "libc/constants")
(libload "libc/stopwatch")
(libload "../../lush/lsh/libimage/morpho")
(libload "idx-float")
(libload "idx-convol")

#? (prototype-cpp-dummy)
;; Load cpp includes.
(de prototype-cpp-dummy ()
  (cpheader "#include \"turtlebot/turtlebot.h\"")
  (cpheader "#include <limits>")
  ())

#? (quaternion2matrix <q> <m>)
;; Convert a quaternion to a 3x3 rotation matrix.
(de quaternion2matrix (q m)
  ((-idx1- (-float-)) q)
  ((-idx2- (-float-)) m)
  (let ((qq (idx-mul q q)))
    (m 0 0 (- (- (+ (qq 3) (qq 0)) (qq 1)) (qq 2)))
    (m 1 1 (- (+ (- (qq 3) (qq 0)) (qq 1)) (qq 2)))
    (m 2 2 (+ (- (- (qq 3) (qq 0)) (qq 1)) (qq 2)))
    (m 0 1 (* 2 (- (* (q 0) (q 1)) (* (q 3) (q 2)))))
    (m 0 2 (* 2 (+ (* (q 3) (q 1)) (* (q 0) (q 2)))))
    (m 1 0 (* 2 (+ (* (q 0) (q 1)) (* (q 3) (q 2)))))
    (m 1 2 (* 2 (- (* (q 1) (q 2)) (* (q 3) (q 0)))))
    (m 2 0 (* 2 (- (* (q 0) (q 2)) (* (q 3) (q 1)))))
    (m 2 1 (* 2 (+ (* (q 3) (q 0)) (* (q 1) (q 2)))))
    )
  m
  )

#? (xyz2global-feature-map <xyz> <tform-gbl> <tform-base> <fm-global> <fm-local>)
;; Uses the global map to orient the local map in global space. Points
;; are integrated only into the local map. After this process, the local
;; map is essentially a ROI in the global map as they are aligned.
(de xyz2global-feature-map (xyz tform-gbl tform-base fm-global fm-local)
  ((-idx2- (-float-)) xyz)
  ((-idx2- (-float-)) tform-gbl)
  ((-idx2- (-float-)) tform-base)
  ((-obj- (feature-map)) fm-global)
  ((-obj- (feature-map)) fm-local)
  ;; Place the feature map center pixel on the pixel closest to the
  ;; robot center in the global map. Compute the offset from the pixel
  ;; center to the robot center and compute the feature map using that
  ;; offset when transforming the point cloud.
  (idx-clear :fm-local:data)
  (let* ((global-cell (int-matrix-nc 2))          ;; Robot position in global map.
         (global-cell-world (float-matrix-nc 3))  ;; Global cell in world coordinates.
         (tform-lcl (float-matrix-nc 4 4))        ;; Robot local transform.
         (tform-full (float-matrix-nc 4 4))       ;; Robot local transform and base transform.
         (map-cell (int-matrix-nc 2))             ;; Target cell for xyz point.
         (xyz-tform (float-matrix-nc 3))          ;; Transformed xyz point.
         )
    
    ;; Compute map cell for robot position in global map.
    (==> fm-global world2map-cell (narrow (select tform-gbl 1 3) 0 3 0) global-cell)
    ;; Get pixel center for global-cell in world coordinates.
    (==> fm-global map-cell2world global-cell (narrow global-cell-world 0 2 0))
    (global-cell-world 2 0)
    ;; Compute local transform for the robot subtracting the global map offset.
    (idx-copy tform-gbl tform-lcl)
    (let ((tform-lcl-trans (narrow (select tform-lcl 1 3) 0 3 0)))
      (idx-sub tform-lcl-trans global-cell-world tform-lcl-trans)
      )
    ;; Apply camera to base link transform and compute map.
    (idx-m2timesm2 tform-lcl tform-base tform-full)
    (xyz2feature-map xyz tform-full fm-local)
    )
  )

;; Time to live for a feature observation.
(defconstant "COST_MAP_GLOBAL_TTL_SECONDS" 120)

#? (de fm-global-decay <fm-global> <cm-global> <cm-global-rgb> <ttl-seconds> <time-now>)
;; Decay a global feature map and cost map with rgb optimiations.
(de fm-global-decay (fm-global cm-global cm-global-rgb ttl-seconds time-now)
  ((-obj- (feature-map)) fm-global)
  ((-obj- (cost-map)) cm-global)
  ((-idx3- (-int-)) cm-global-rgb)
  ((-float-) ttl-seconds)
  ((-float-) time-now)
  (let ((time-cutoff (- time-now ttl-seconds))
        (blue [i 0 0 255])
        )
    (idx-pbloop ((fm-r :fm-global:data)(cm-r :cm-global:data)(cm-rgb-r cm-global-rgb))
      (idx-bloop ((fm fm-r)(cm cm-r)(cm-rgb cm-rgb-r))
        ;; Reset point when last-seen time is too old.
        (if (< (fm @FEATURE_MAP_IDX_COUNT) time-cutoff)
          (progn
            (idx-clear fm)
            ;; reissb -- 20120201 -- Can't get inifinity to compile.
            ;;(fm @FEATURE_MAP_IDX_COUNT 9999999999.1)
            (fm @FEATURE_MAP_IDX_COUNT (to-float #{ std::numeric_limits<float>::infinity() #}))
            (cm 0 @COST_MAP_INF_COST)
            (idx-copy blue cm-rgb)
            )
          )
        )
      )
    )
  )

;; Exponential moving average weight used to blend new observations into the
;; global feature map.
(defconstant "COST_MAP_GLOBAL_EXP_MOV_AVG_WT" 0.9)

;; Erode a ubyte matrix using a structuring element of 1 pixel. This
;; is an optimized erosion that does not interpolate borders.
;;
;; Benchmarks on AMD E-350 APU machine:
;; ? (setq img (ubyte-matrix 40 40))
;; ? (setq img-erode (ubyte-matrix 40 40))
;; ? (cputime (repeat 400000 (erode img img-erode)))
;; = 8.11
;; ? (cputime (repeat 400000 (erode img img-erode)))
;; = 8.09
;; ? (cputime (repeat 400000 (ubim-erosion img 1)))
;; = 13.29
;; ? (cputime (repeat 400000 (ubim-erosion img 1)))
;; = 13.23
;; ?
(de erode (src dst)
  ((-idx2- (-ubyte-)) src)
  ((-idx2- (-ubyte-)) dst)
  ;; Check sizes.
  (let ((r (idx-dim src 0)) (c (idx-dim src 1)))
    ((-int-) r) ((-int-) c)
    (when (or (< r 3) (< c 3))
      (error "insufficient source image size"))
    (when (or (<> r (idx-dim dst 0)) (<> c (idx-dim dst 1)))
      (error "insufficient destination image size"))
    ;; Erode using column sums. Need solid 9x9.
    (cpheader "#include <algorithm>")
    (cpheader "#include <stdint.h>")
    #{
      {
        uint8_t* const dst_begin = IDX_PTR($dst, uint8_t);
        // Step through rows and columns. Need all sum of 9 to have a pixel.
        const int rows = ($src)->dim[0];
        const int cols = ($src)->dim[1];
        const int row_steps = rows - 2;
        const int col_steps = cols - 2;
        const int row_mod = ($src)->mod[0];
        const int col_mod = ($src)->mod[1];
        const int plus_2_col = 2 * col_mod;
        for (int r = 0; r < row_steps; ++r)
        {
          const uint8_t* src_r0 = (r * row_mod) + IDX_PTR($src, uint8_t);
          const uint8_t* src_r1 = src_r0 + row_mod;
          const uint8_t* src_r2 = src_r1 + row_mod;
          uint8_t* dst_px = dst_begin + (r * row_mod) + col_mod;
          // Initialize column sums.
          int col_sums[3] = {0};
          for (int c = 0, offset = 0; c < 3; ++c, offset += col_mod)
          {
            col_sums[c] += *(src_r0 + offset) > 0;
            col_sums[c] += *(src_r1 + offset) > 0;
            col_sums[c] += *(src_r2 + offset) > 0;
          }
          for (int c = 0; c < col_steps; ++c,
               // Advance rows.
               src_r0 += col_mod, src_r1 += col_mod, src_r2 += col_mod,
               // Shift column sums.
               col_sums[0] = col_sums[1],
               col_sums[1] = col_sums[2],
               col_sums[2] = (*(src_r0 + plus_2_col) > 0) +
                             (*(src_r1 + plus_2_col) > 0) +
                             (*(src_r2 + plus_2_col) > 0),
               dst_px += col_mod)
          {
            const int pixel_sum = (*src_r1 > 0) + col_sums[1] + (*(src_r1 + plus_2_col) > 0);
            *dst_px = (5 == pixel_sum);
          }
        }
        // Just black out border.
        {
          uint8_t* dst_px;
          dst_px = dst_begin;
          for (int c = 0; c < cols; ++c, dst_px += col_mod) { *dst_px = 0; }
          dst_px = dst_begin + ((rows - 1) * row_mod);
          for (int c = 0; c < cols; ++c, dst_px += col_mod) { *dst_px = 0; }
          dst_px = dst_begin;
          for (int r = 0; r < rows; ++r, dst_px += row_mod) { *dst_px = 0; }
          dst_px = dst_begin + row_mod - col_mod;
          for (int r = 0; r < rows; ++r, dst_px += row_mod) { *dst_px = 0; }
        }
      }
      #}
    )
  ()
  )

#? (erode-test)
;; Visual test of erosion.
(de erode-test ()
  (let* ((img-dim 300)
         (img       (ubyte-matrix img-dim img-dim))
         (img-erode (ubyte-matrix img-dim img-dim))
         (scale 1)
         )
    ;; Generate a random image.
    (idx-bloop ((img-r img)) (idx-bloop ((px img-r)) (px (to-int (+ (rand) 0.1)))))
    (for (i 1 2) (ubim-dilation img 1))
    (erode img img-erode)
    (if (= () window) (new-window 640 480))
    (cls)
    (gray-draw-matrix 0                 0 img       0 1 scale scale)
    (gray-draw-matrix (* scale img-dim) 0 img-erode 0 1 scale scale)
    )
  ()
  )

;; Resample a local feature map by solving a least squares optimization.
(de fm-local-registration (fm-lcl fm-gbl fm-gbl-cell rot offset window-dim)
  ;; Find correspondences by looking in a square neighborhood about the image of
  ;; significant features in the global map projected into the local map.
  ;; Define sigificant features by their feature vector
  ;;   pts mean, pts variance, (TODO) rgb mean, rgb variance
  (let* (;; Full size data.
         (r (:fm-lcl:full-dim 0))
         (c (:fm-lcl:full-dim 1)) 
         (gbl-crop-ul (idx-sub fm-gbl-cell :fm-lcl:half-dim))
         (fm-gbl-crop (narrow (narrow :fm-gbl:data 0 r (gbl-crop-ul 0)) 1 c (gbl-crop-ul 1)))
         (num-feat (+ 2 @FEATURE_MAP_HT_BIN_COUNT))
         (fm-gbl-feat (float-matrix-nc r c num-feat))
         (fm-lcl-feat (float-matrix-nc r c num-feat))
         (fm-gbl-masks (ubyte-matrix-nc r c 2))
         (fm-lcl-masks (ubyte-matrix-nc r c 2))
;;         ;; Stages with 3x3 convolution.
;;         (r-conv (- r 2)) (c-conv (- c 2))
;;         (fm-gbl-feat-conv (float-matrix-nc r-conv c-conv num-feat))
;;         (fm-lcl-feat-conv (float-matrix-nc r-conv c-conv num-feat))
         ;; General variables.
         (neigh-size (+ (* 2 window-dim) 1))
         (num-pts 0)
         )

    ;; ******************** FEATURE EXTRACTION ********************
    ;; ******************** FEATURE EXTRACTION ********************
    ;; ******************** FEATURE EXTRACTION ********************
    (idx-pbloop ((fm-gbl-r fm-gbl-crop)
                 (fm-lcl-r :fm-lcl:data)
                 (fm-gbl-mask-r (select fm-gbl-masks 2 0))
                 (fm-lcl-mask-r (select fm-lcl-masks 2 0))
                 (fm-gbl-feat-r fm-gbl-feat)
                 (fm-lcl-feat-r fm-lcl-feat)
                 )
      (idx-pbloop ((fm-gbl fm-gbl-r)
                   (fm-lcl fm-lcl-r)
                   (fm-gbl-mask fm-gbl-mask-r)
                   (fm-lcl-mask fm-lcl-mask-r)
                   (fm-gbl-feat fm-gbl-feat-r)
                   (fm-lcl-feat fm-lcl-feat-r)
                   )
        ;; Mask only when there are no points.
        (fm-gbl-mask (if (> (fm-gbl @FEATURE_MAP_0_NUM_PTS) 0) 1 0))
        (fm-lcl-mask (if (> (fm-lcl @FEATURE_MAP_0_NUM_PTS) 0) 1 0))
        ;; Compute mean, variance, histogram.
        (let ((gbl-num (fm-gbl @FEATURE_MAP_0_NUM_PTS))
              (lcl-num (fm-lcl @FEATURE_MAP_0_NUM_PTS))
              (gbl-sum-x (fm-gbl @FEATURE_MAP_1_SUM_HT))
              (lcl-sum-x (fm-lcl @FEATURE_MAP_1_SUM_HT))
              (gbl-sum-xx (fm-gbl @FEATURE_MAP_2_SUM_HT_SQ))
              (lcl-sum-xx (fm-lcl @FEATURE_MAP_2_SUM_HT_SQ))
              (hist-gbl-denorm (narrow fm-gbl 0 @FEATURE_MAP_HT_BIN_COUNT @FEATURE_MAP_3_NUM_HT_BIN_0))
              (hist-lcl-denorm (narrow fm-lcl 0 @FEATURE_MAP_HT_BIN_COUNT @FEATURE_MAP_3_NUM_HT_BIN_0))
              (hist-gbl-norm (narrow fm-gbl-feat 0 @FEATURE_MAP_HT_BIN_COUNT 2))
              (hist-lcl-norm (narrow fm-lcl-feat 0 @FEATURE_MAP_HT_BIN_COUNT 2))
              )
          (if (<> 0 gbl-num)
            (let* ((gbl-mu (/ gbl-sum-x gbl-num))
                   (gbl-var (+ (/ (- gbl-sum-xx (* 2 (* gbl-mu gbl-sum-x))) gbl-num) (* gbl-mu gbl-mu)))
                   )
              (fm-gbl-feat 0 gbl-mu)
              (fm-gbl-feat 1 gbl-var)
              (idx-f1dotc hist-gbl-denorm (/ 1.0 gbl-num) hist-gbl-norm)
              )
            (idx-clear fm-gbl-feat)
            )
          (if (<> 0 lcl-num)
            (let* ((lcl-mu (/ lcl-sum-x lcl-num))
                   (lcl-var (+ (/ (- lcl-sum-xx (* 2 (* lcl-mu lcl-sum-x))) lcl-num) (* lcl-mu lcl-mu)))
                   )
              (fm-lcl-feat 0 lcl-mu)
              (fm-lcl-feat 1 lcl-var)
              (idx-f1dotc hist-lcl-denorm (/ 1.0 lcl-num) hist-lcl-norm)
              )
            (idx-clear fm-lcl-feat)
            )
          )
        )
      )
    ;; Erode and show mask.
    ;;(erode (select fm-masks 2 0) (select fm-masks 2 1))
    (idx-copy (select fm-gbl-masks 2 0 )(select fm-gbl-masks 2 1))
    (idx-copy (select fm-lcl-masks 2 0 )(select fm-lcl-masks 2 1))
    (gray-draw-matrix (:fm-gbl:full-dim 1) (* 1 r) (select fm-lcl-masks 2 1) 0 1 1 1)
;;    ;; Perform convolutions using laplacian kernel.
;;    (let ((edge-kernel (float-matrix-nc 3 3)))
;;      (idx-f2fill edge-kernel -1)(edge-kernel 1 1 8)
;;      (idx-peloop ((fm-gbl-feat fm-gbl-feat) (fm-gbl-feat-conv fm-gbl-feat-conv)
;;                   (fm-lcl-feat fm-lcl-feat) (fm-lcl-feat-conv fm-lcl-feat-conv)
;;                   )
;;        (idx-f2convol fm-gbl-feat edge-kernel fm-gbl-feat-conv)
;;        (idx-f2convol fm-lcl-feat edge-kernel fm-lcl-feat-conv)
;;        )
;;      )
    (gray-draw-matrix (+ (:fm-gbl:full-dim 1) c) (* 0 r) (select fm-gbl-feat 2 0) 0 3.0 1 1)
    (gray-draw-matrix (+ (:fm-gbl:full-dim 1) c) (* 1 r) (select fm-gbl-feat 2 1) 0 0.1 1 1)
    ;; ******************** FEATURE EXTRACTION ********************
    ;; ******************** FEATURE EXTRACTION ********************
    ;; ******************** FEATURE EXTRACTION ********************

    ;; ******************** INTEREST POINT DETECTION & MATCHING ********************
    ;; ******************** INTEREST POINT DETECTION & MATCHING ********************
    ;; ******************** INTEREST POINT DETECTION & MATCHING ********************
    (let* ((fm-gbl-feat-neigh (unfold (unfold fm-gbl-feat 0 neigh-size 1) 1 neigh-size 1))
           (fm-lcl-feat-neigh (unfold (unfold fm-lcl-feat 0 neigh-size 1) 1 neigh-size 1))
           (fm-gbl-masks-neigh (unfold (unfold fm-gbl-masks 0 neigh-size 1) 1 neigh-size 1))
           (fm-lcl-masks-neigh (unfold (unfold fm-lcl-masks 0 neigh-size 1) 1 neigh-size 1))
           (r-match (idx-dim fm-gbl-feat-neigh 0))
           (c-match (idx-dim fm-gbl-feat-neigh 1))
           (fm-gbl-masks-match (narrow (narrow fm-gbl-masks 0 r-match window-dim) 1 c-match window-dim))
           (fm-lcl-masks-match (narrow (narrow fm-lcl-masks 0 r-match window-dim) 1 c-match window-dim))
           (fm-gbl-pt (narrow (narrow  fm-gbl-crop 0 r-match window-dim) 1 c-match window-dim))
           (fm-lcl-pt (narrow (narrow :fm-lcl:data 0 r-match window-dim) 1 c-match window-dim))
           (fm-gbl-feat-pt (narrow (narrow fm-gbl-feat 0 r-match window-dim) 1 c-match window-dim))
           (fm-lcl-feat-pt (narrow (narrow fm-lcl-feat 0 r-match window-dim) 1 c-match window-dim))

           (px-correspond-gbl (double-matrix-nc 1000 2))
           (px-correspond-lcl (double-matrix-nc 1000 2))
           (img-dispar (ubyte-matrix r c 3))
           (img-dispar-match (narrow (narrow img-dispar 0 r-match window-dim) 1 c-match window-dim))

           (masked-pts 0)
           (sum-x (float-matrix num-feat))
           (sum-xx (float-matrix num-feat))
           (mu (float-matrix-nc num-feat))
           (var (float-matrix-nc num-feat))
           (i window-dim)
           (j window-dim)
           (num-matched 0)
           )
      ;; Compute mean, variance for all feature vectors in global map.
      (idx-bloop ((fm-gbl-feat fm-gbl-feat)
                  (fm-gbl-masks (select fm-gbl-masks 2 1))
                  )
        (idx-bloop ((fm-gbl-feat fm-gbl-feat)
                    (fm-gbl-masks fm-gbl-masks)
                    )
          (if (= 0 (fm-gbl-masks))
            () ;; Do nothing if no data here.
            (incr masked-pts)
            (idx-add fm-gbl-feat sum-x sum-x)
            (idx-f1mulacc fm-gbl-feat fm-gbl-feat sum-xx)
            )
          )
        )
      (if (= 0 masked-pts)
        () ;; Do nothing if there are no points in the global map.
        ;; Compute mean, var.
        (idx-f1dotc sum-x (/ 1.0 masked-pts) mu)
        ;; Var = ((Sum(X_i^2) - (2 * Mu * Sum(X_i))) / N) + Mu^2
        (idx-mul mu sum-x var)
        (idx-f1dotc var 2 var)
        (idx-sub sum-xx var var)
        (idx-f1dotc var (/ 1.0 masked-pts) var)
        (idx-f1mulacc mu mu var)
        ;; Loop over all points. If the global point is interesting, then look
        ;; for it in the local neighborhood.
        (idx-bloop ((fm-lcl-feat-neigh fm-lcl-feat-neigh)
                    (fm-lcl-masks-neigh fm-lcl-masks-neigh)
                    (fm-gbl-feat-pt fm-gbl-feat-pt)
                    (fm-gbl-pt fm-gbl-pt)
                    (img-dispar-match img-dispar-match)
                    (fm-gbl-masks-match fm-gbl-masks-match)
                    (fm-gbl-masks-neigh fm-gbl-masks-neigh)
                    )
          (setq j window-dim)
          (idx-bloop ((fm-lcl-feat-neigh fm-lcl-feat-neigh)
                      (fm-lcl-masks-neigh fm-lcl-masks-neigh)
                      (fm-gbl-feat-pt fm-gbl-feat-pt)
                      (fm-gbl-pt fm-gbl-pt)
                      (img-dispar-match img-dispar-match)
                      (fm-gbl-masks-match fm-gbl-masks-match)
                      (fm-gbl-masks-neigh fm-gbl-masks-neigh)
                      )
            ;; See if this point is interesting.
            (let ((p 1.0) (norm 1.0) (sqrt-2-pi (sqrt (* 2 3.14159265))))
              (idx-bloop ((mu mu)(var var)(x fm-gbl-feat-pt))
                (if (<> 0 (var))
                  (progn
                    (setq norm (/ 1.0 (* (var) sqrt-2-pi)))
                    (setq p (* p (exp (- (/ (** (abs (- (x) (mu))) 2) (* 2 (var))))) norm))
                    )
                  )
                )
              (if (and (<> 0 (fm-gbl-masks-match 1)) (< p 0.1))
               (progn
                 (incr num-matched)
                 (img-dispar-match 1 255)
                 (printf "interest-pt (%d, %d), p = %f, fm-gbl-feat-pt =\n" i j p)
                 (pretty fm-gbl-feat-pt)
                 (pretty fm-gbl-pt)
                 ;; Find this point in the local map.
                 )
                )
              )
            (incr j)
            )
          (incr i)
          )
        )
        (rgb-draw-matrix (:fm-gbl:full-dim 1) (* 2 r) img-dispar-match 1 1)
;;      ;; Loop over all pixels looking for interesting ones.
;;      (idx-bloop ((gbl-search-neigh-r gbl-search-neigh)
;;                  (gbl-search-mask-neigh-r gbl-search-mask-neigh)
;;                  (fm-gbl-r (narrow (narrow (narrow fm-gbl-crop 0 r-feat window-dim)
;;                                    1 c-feat window-dim) 2 2 1))
;;                  (fm-lcl-neigh-r fm-lcl-neigh)
;;                  (fm-lcl-mask-neigh-r fm-lcl-mask-neigh)
;;                  )
;;        (setq j window-dim)
;;        (idx-bloop ((gbl-search-neigh gbl-search-neigh-r)
;;                    (gbl-search-mask-neigh gbl-search-mask-neigh-r)
;;                    (fm-gbl-pt fm-gbl-r)
;;                    (fm-lcl-neigh fm-lcl-neigh-r)
;;                    (fm-lcl-mask-neigh fm-lcl-mask-neigh-r)
;;                    )
;;          (let* ((discard (<> 9 ((idx-sum gbl-search-mask-neigh))))
;;                 (gbl-search-pt (select (select gbl-search-neigh 1 1) 1 1))
;;                 (gbl-search-pt-norm-sq (idx-m1dotm1 gbl-search-pt gbl-search-pt))
;;                 )
;;            (if (not discard)
;;              (if (< (gbl-search-pt-norm-sq) 0.1)
;;                (setq discard t)
;;                ;; Look at uniqueness in the region.
;;                (let ((p 1))
;;                  (idx-bloop ((mu mu)(var var)(x gbl-search-pt))
;;                    (if (<> 0 (var))
;;                      (setq p (* p (exp (- (/ (** (abs (- (x) (mu))) 2) (* 2 (var)))))))
;;                      )
;;                    )
;;;;                    (printf "p = %f\n" p)
;;                  (setq discard (> p 0.01))
;;                  )
;;                )
;;              )
;;            (if discard
;;              () ;; Do nothing when discarded.
;;              (disparity-map i j 1 255)
;;              ;; Find this point in the local map window.
;;;;                (printf "found pt match (%d, %d)\n" i j)
;;;;                (pretty fm-gbl-pt)
;;;;                (pretty (select (select fm-gbl-crop 0 i) 0 j))
;;;;                (pretty (select (select :fm-lcl:data 0 i) 0 j))
;;;;                (pretty fm-lcl-neigh)
;;              (let ((diff-tmp (float-matrix-nc 2))
;;                    (dist-sq [f@ 0])
;;                    (min-dist-sq (idx-m1dotm1 fm-gbl-pt fm-gbl-pt))
;;                    (min-cell [i 0 0])
;;                    (world-cell-tmp (float-matrix-nc 2))
;;                    (cell (int-matrix-nc 2))
;;;;                    ;; DEBUG sq diff.
;;;;                    (dbg-sq-diff (float-matrix-nc neigh-size neigh-size))
;;;;                    ;; DEBUG sq diff.
;;                    )
;;;;                ;; DEBUG sq diff.
;;;;                (idx-f2fill dbg-sq-diff -1)
;;;;                ;; DEBUG sq diff.
;;                ;; Subtract fm-gbl-pt from the neighborhood and take norm square.
;;                (for (i (- window-dim) window-dim)
;;                  (for (j (- window-dim) window-dim)
;;                    (let* ((i-pt (+ i window-dim))
;;                           (j-pt (+ j window-dim))
;;                           (fm-lcl-pt (select (select fm-lcl-neigh 1 i-pt) 1 j-pt))
;;                           (mask-pt (select (select fm-lcl-mask-neigh 0 i-pt) 0 j-pt))
;;                           )
;;                      ;; Make sure masked.
;;                      (if (= 0 (mask-pt))
;;                        () ;; Don't match if not masked.
;;                        ;; See if closest match.
;;                        (idx-sub fm-gbl-pt fm-lcl-pt diff-tmp)
;;                        (idx-m1dotm1 diff-tmp diff-tmp dist-sq)
;;;;                        ;; DEBUG sq diff.
;;;;                        (dbg-sq-diff i-pt j-pt (dist-sq))
;;;;                        ;; DEBUG sq diff.
;;                        (if (>= (dist-sq) (min-dist-sq))
;;                          () ;; No update when not the new min.
;;                          (idx-copy dist-sq min-dist-sq)
;;                          (min-cell 0 i) (min-cell 1 j)
;;                          )
;;                        )
;;                      )
;;                    )
;;                  )
;;;;                (printf "closest (%d,%d) = %f\n" (min-cell 0) (min-cell 1) (min-dist-sq))
;;;;                ;; DEBUG sq diff.
;;;;                (pretty dbg-sq-diff)
;;;;                ;; DEBUG sq diff.
;;
;;                (cell 0 i) (cell 1 j)
;;;;                  (pretty cell)
;;                (==> fm-lcl map-cell2world cell world-cell-tmp)
;;                (idx-copy world-cell-tmp (select px-correspond-gbl 0 num-pts))
;;                (idx-add cell min-cell cell)
;;;;                  (pretty cell)
;;                (disparity-map (cell 0) (cell 1) 0 255)
;;                (==> fm-lcl map-cell2world cell world-cell-tmp)
;;                (idx-copy world-cell-tmp (select px-correspond-lcl 0 num-pts))
;;                (incr num-pts)
;;                )
;;              )
;;            )
;;          (incr j)
;;          )
;;        (incr i)
;;        )
;;      (rgb-draw-matrix (:fm-gbl:full-dim 1) (* 2 r) disparity-map 1 1)
;;
;;      ;; Perform registration between maps when there are enough point correspondences.
;;      (if (> num-pts 10)
;;        (let ((rot-d (double-matrix-nc 2 2))
;;              (offset-d (double-matrix-nc 2))
;;              )
;;          (printf "There were %d point correspondences\n" num-pts) 
;;          (map-registration (narrow px-correspond-gbl 0 num-pts 0)
;;                            (narrow px-correspond-lcl 0 num-pts 0) rot-d offset-d)
;;          (idx-copy rot-d rot)
;;          (idx-copy offset-d (narrow offset 0 2 0)) (offset 0 0)
;;          )
;;        )
      )
    num-pts
    )
  )

;; Take a local feature map and integrate it into a global feature map.
(de fm-global-update (fm-global cm-global cm-global-rgb fm-global-cell fm-local time-now)
  ((-obj- (feature-map)) fm-global)
  ((-obj- (cost-map)) cm-global)
  ((-idx3- (-int-)) cm-global-rgb)
  ((-idx1- (-int-)) fm-global-cell)
  ((-obj- (feature-map)) fm-local)
  ((-float-) time-now)
  ;; Decay the global feature map.
  (fm-global-decay fm-global cm-global cm-global-rgb @COST_MAP_GLOBAL_TTL_SECONDS time-now)
  ;; Integrate fm-local into fm-global.
  (let ((ul (idx-sub fm-global-cell :fm-local:half-dim))
        (lr (idx-add fm-global-cell :fm-local:half-dim))
        (roi (int-matrix-nc 4))
        (mask-rows 0)
        (mask-cols 0)
        )
    (roi 0 (max (ul 0) 0))
    (roi 1 (max (ul 1) 0))
    (roi 2 (min (lr 0) (:fm-global:full-dim 0)))
    (roi 3 (min (lr 1) (:fm-global:full-dim 1)))
    (setq mask-rows (+ (- (roi 2) (roi 0)) 1))
    (setq mask-cols (+ (- (roi 3) (roi 1)) 1))
    ;; Make sure that mask is in bounds.
    (if (or (<= mask-rows 0) (<= mask-cols 0))
      () ;; Do nothing when mask is out of bounds.

      ;; Mask fm-global, cm-global and integrate fm-local.
      (let ((fm-global-mask
              (narrow (narrow :fm-global:data 0 mask-rows (ul 0)) 1 mask-cols (ul 1)))
            (cm-global-mask
              (narrow (narrow :cm-global:data 0 mask-rows (ul 0)) 1 mask-cols (ul 1)))
            (prev-data-wt (- 1.0 @COST_MAP_GLOBAL_EXP_MOV_AVG_WT))
            (update-data-weighted (float-matrix-nc @FEATURE_MAP_IDX_COUNT))
            )
        ;; TODO(reissb) -- Clip fm-local.
        (idx-pbloop ((fm-global-r fm-global-mask)(fm-local-r :fm-local:data))
          (idx-bloop ((fm-g fm-global-r)(fm-l fm-local-r))
            ;; Weighted average of the features.
            (if (= (fm-l 0) 0)
              () ;; Do nothing when there is no data (already decayed).

              (let ((fm-g-trunc (narrow fm-g 0 @FEATURE_MAP_IDX_COUNT 0)))
                ;; See if this is the first update.
                (if (= (fm-g-trunc 0) 0)
                  ;; No average for first update.
                  (idx-copy fm-l fm-g-trunc)
                  ;; Else exponential moving average.
                  (idx-f1dotc fm-l @COST_MAP_GLOBAL_EXP_MOV_AVG_WT update-data-weighted)
                  (idx-f1dotc fm-g-trunc prev-data-wt fm-g-trunc)
                  (idx-add fm-g-trunc update-data-weighted fm-g-trunc)
                  )
                ;; Update last-seen time.
                (fm-g @FEATURE_MAP_IDX_COUNT time-now)
                )
              )
            )
          )
        ;; Compute global cost map.
        (feature-map2cost-map fm-global-mask cm-global-mask)
        )
      )
    )
  )

(de xyz2global-feature-map-test (tb n)
  (==> tb start-sub-camera-depth-points)
;;  (==> tb start-sub-robot-pose-ekf)
;;  (==> tb start-sub-odom)
  ;; Create feature, cost, and cost rgb maps.
  (let* ((scale [f 0.05 0.05])
         (fm-global (new feature-map [i 200 200] scale (+ @FEATURE_MAP_IDX_COUNT 1)))
         (cm-global ())
         (cm-global-rgb ())
         (fm-local (new feature-map [i 80 80] scale @FEATURE_MAP_IDX_COUNT))
         (cm-local ())
         (cm-local-rgb ())
         (fm-global-cell (int-matrix-nc 2))
         (tmr (new stopwatch))
         (tform-odom-correct (float-matrix 4 4))
         )
    (for (i 0 3) (tform-odom-correct i i 1))
    (idx-f2fill (select :fm-global:data 2 @FEATURE_MAP_IDX_COUNT) (- (infinity)))
    ;; Setup cost maps.
    (idx-copy :fm-global:half-dim :fm-global:center)
    (setq cm-global (new cost-map fm-global))
    (setq cm-global-rgb (int-matrix (:cm-global:full-dim 0) (:cm-global:full-dim 1) 3))
    (idx-copy :fm-local:half-dim :fm-local:center)
    (setq cm-local (new cost-map fm-local))
    (setq cm-local-rgb (int-matrix (:cm-local:full-dim 0) (:cm-local:full-dim 1) 3))
    ;; Create properly sized window if it doesn't exist.
    (if (not window) (
      let ((wnd-width 0)(wnd-height 0))
        (setq wnd-width (+ (idx-dim cm-global-rgb 1) (idx-dim cm-local-rgb 1)))
        (setq wnd-height (idx-dim cm-global-rgb 0))
        (new-window 0 0 wnd-width wnd-height)
        )
      )
    ;; Do n loops of processing.
    (for (i 0 (- n 1))
      ;; Grab new data.
;;      (while (< (==> tb update-robot-pose-ekf) 0) ())
;;      (while (< (==> tb update-odom) 0) ())
      (while (< (==> tb update-camera-depth-points) 0) ())
      ;; Convert points to feature map.
      (let ((tform-odom (float-matrix 4 4))
            (odom-orien (float-matrix 4))
            (odom-pos (float-matrix 3))
            (tform-odom-corrected (float-matrix 4 4))
            (tform-full (float-matrix 4 4))
            )
        ;; Update transform using odometry.
;;        (idx-copy :tb:odom-pose-position odom-pos)
;;        (idx-copy :tb:odom-pose-orientation odom-orien)
        (idx-copy :tb:robot-pose-ekf-position odom-pos)
        (idx-copy :tb:robot-pose-ekf-orientation odom-orien)
        ;; Flip the angle (invert).
        (odom-orien 3 (- (odom-orien 3)))
        (quaternion2matrix odom-orien tform-odom)
        ;; Apply orientation to the position.
        (idx-m2dotm1 (narrow (narrow tform-odom 0 3 0) 1 3 0) odom-pos
                     (select (narrow tform-odom 0 3 0) 1 3))
        (tform-odom 3 3 1)
;;        (printf "tform-odom\n") (pretty tform-odom)
        ;; Correct the odometry using the last correction factor.
        (idx-m2timesm2 tform-odom-correct tform-odom tform-odom-corrected)
        (printf "tform-odom-correct\n") (pretty tform-odom-correct)
        (printf "cos(theta) : %0.5f\n" (tform-odom-correct 0 0))
        (printf "sin(theta) : %0.5f\n" (tform-odom-correct 1 0))
        ;; Get robot world position in map coordinates.
        (==> fm-global world2map-cell (select tform-odom-corrected 1 3) fm-global-cell)
        ;; Compute local map using current odometry guess.
        (xyz2global-feature-map :tb:camera-depth-points
                                tform-odom-corrected turtlebot-c2v fm-global fm-local)
        ;; Register feature maps using visual odometry.
        (let* ((tform-odom-correct-upd (float-matrix 4 4))
               (tform-odom-correct-upd-rot (narrow (narrow tform-odom-correct-upd 0 2 0) 1 2 0))
               (tform-odom-correct-upd-trans (select (narrow tform-odom-correct-upd 0 3 0) 1 3))
               (num-matched 0)
               )
          (for (i 0 3) (tform-odom-correct-upd i i 1))
          (setq num-matched (fm-local-registration fm-local fm-global fm-global-cell
                                                   tform-odom-correct-upd-rot
                                                   tform-odom-correct-upd-trans 3))
          (if (= 0 num-matched)
            () ;; Do nothing when no registration information.
            ;; Update odometry correction transformation by adding the current one.
            (progn
              (idx-copy tform-odom-correct tform-odom-corrected)
              (idx-m2timesm2 tform-odom-correct-upd tform-odom-corrected tform-odom-correct)
              )
            ;; Correct the odometry using the new correction factor.
            (idx-m2timesm2 tform-odom-correct tform-odom tform-odom-corrected)
;;            (printf "tform-odom-corrected\n") (pretty tform-odom-corrected)
            ;; Get robot world position in map coordinates.
            (==> fm-global world2map-cell (select tform-odom-corrected 1 3) fm-global-cell)
            ;; Compute local map using current odometry guess.
            (xyz2global-feature-map :tb:camera-depth-points
                                    tform-odom-corrected turtlebot-c2v fm-global fm-local)
            )
          )
        )
      (progn (feature-map2cost-map :fm-local:data :cm-local:data)
             (setq :cm-local:pcl-density :fm-local:pcl-density))
      ;; Update global map (with cost map rgb optimizations).
      (fm-global-update fm-global cm-global cm-global-rgb fm-global-cell fm-local (==> tmr get))
      ;; Prepare for display.
      (cost-map2rgb 0.5 cm-global cm-global-rgb)
      (cost-map2rgb 0.5 cm-local cm-local-rgb)
      ;; Draw maps.
      (rgb-draw-matrix 0 0 cm-global-rgb 1 1)
      (rgb-draw-matrix (idx-dim cm-global-rgb 1) 0 cm-local-rgb 1 1)
      )
    )
  )

;;(let ((dhc-make-lushflags (concat dhc-make-lushflags " -fopenmp")))
  (dhc-make-with-c++ () () ;;"/usr/lib/gcc/i486-linux-gnu/4.4/libgomp.so"
    prototype-cpp-dummy
    quaternion2matrix
    xyz2global-feature-map
    fm-global-decay
    fm-global-update
    erode
    )
;;  )

