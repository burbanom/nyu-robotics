(libload "turtlebot/turtlebot")

#? turtlebot-c2v
;; Transformation from Kinect to Turtlebot base.
(defparameter turtlebot-c2v [f [0 0 1 -0.10] [1 0 0 -0.01] [0 1 0 -0.25]])

#? feature-map
;; A generic structure used to store feature vectors. Has center and
;; scale parameters best for rectangular maps.
(defclass feature-map object
  ((-idx3- (-float-)) data)
  ((-idx1- (-float-)) scale)
  ((-idx1- (-int-)) center)
  ((-idx1- (-int-)) full-dim)
  ((-idx1- (-int-)) half-dim)
  ((-int-) features)
  )

#? (new feature-map <half-dim> <scale> <features>)
;; Create a feature map with the given dimensions and scale. For each of the
;; cells there is a single feature vector with <features> entries. This data
;; has no implicit semantics.
(defmethod feature-map feature-map (half-dim- scale- features-)
  ((-idx1- (-int-)) half-dim-)
  ((-idx1- (-float-)) scale-)
  ((-int-) features-)
  (setq half-dim (idx-copy half-dim-))
  (setq scale (idx-copy scale-))
  (setq features features-)
  (setq center (idx-mul half-dim [i 2 1]))
  (setq full-dim (idx-add (idx-mul half-dim [i 2 2]) [i 1 1]))
  (setq data (float-matrix (full-dim 0) (full-dim 1) features))
  )

#? (==> <feature-map> world2map-cell <world-coord> <cell>)
;; Compute the map cell for the given world coordinate. The origin is always
;; the map center.
(defmethod feature-map world2map-cell (world-coord cell)
  ((-idx1- (-float-)) world-coord)
  ((-idx1- (-int-)) cell)
  (let ((x-offset (/ (world-coord 1) (scale 0)))
        (y-offset (/ (world-coord 0) (scale 1))))
    (idx-copy center cell)
    (cell 0 (+ (cell 0) (* y-offset -1)))
    (cell 1 (+ (cell 1) x-offset))
    )
  cell
  )

#? (==> <feature-map> in-bounds <cell>)
;; Test if cell is within the map area.
(defmethod feature-map in-bounds (cell)
  ((-idx1- (-int-)) cell)
  (and (and (>= (cell 0) 0) (>= (cell 1) 0))
       (and (< (cell 0) (full-dim 0)) (< (cell 1) (full-dim 1))))
  )

#? cost-map
;; A single float per cell of a related feature-map.
(defclass cost-map feature-map
  ((-int-) inf-cost)
  )

#? (new cost-map <fm>)
;; Construct a cost-map from an existing feature-map <fm>.
(defmethod cost-map cost-map (fm)
  ((-obj- (feature-map)) fm)
  (setq inf-cost 9999)
  (==> this feature-map :fm:half-dim :fm:scale 1)
  )

#? (vec3tformcoord <v> <mat> <res>)
;; Transform 3d vector <v> by the matrix <mat>. This function will ignore
;; any transformations in homogenous coordinate w.
(de vec3tformcoord (v mat res)
  ((-idx1- (-float-)) v)
  ((-idx2- (-float-)) mat)
  ((-idx1- (-float-)) res)
  (let ((rows (idx-dim mat 0)))
    (idx-changedim mat 0 3)
    (idx-m0clear res)
    (idx-pbloop ((mat-r mat)(res-c res))
      ;; Apply rotation and scale.
      (idx-changedim mat-r 0 3)
      (idx-bloop ((mat-rc mat-r)(v-c v))
        (res-c (+ (res-c) (* (mat-rc) (v-c))))
        )
      (idx-changedim mat-r 0 4)
      ;; Apply translation.
      (res-c (+ (res-c) (mat-r 3)))
      )
    (idx-changedim mat 0 rows)
    )
  res
  )

#?  (xyz2feature-map <xyz> <transform> <fm>)
;; Fill in feature map for each map cell using the point cloud <xyz>
;;   Features:
;;   [0] - Number of points.
;;   [1] - Sum of heights.
;;   [2] - Sum of squared heights.
(de xyz2feature-map (xyz transform fm)
  ((-idx2- (-float-)) xyz)
  ((-idx2- (-float-)) transform)
  ((-obj- (feature-map)) fm)
  (let ((map-cell [i 0 0])               ;; Target cell for xyz point.
        (xyz-tform (float-matrix-nc 3))) ;; Transformed xyz point.
    (idx-clear :fm:data)
    ;; For all point cloud points.
    (idx-bloop ((xyz xyz))
      ;; Transform to robot world.
      (vec3tformcoord xyz transform xyz-tform)
      ;; Find target cell.
      (==> fm world2map-cell xyz-tform map-cell)
      ;; Check cell in bounds.
      (if (==> fm in-bounds map-cell)
        (let ((h (* -1 (xyz-tform 2))))
          ;; Increment count.
          (:fm:data (map-cell 0) (map-cell 1) 0
            (+ (:fm:data (map-cell 0) (map-cell 1) 0) 1))
          ;; Sum height.
          (:fm:data (map-cell 0) (map-cell 1) 1
            (+ (:fm:data (map-cell 0) (map-cell 1) 1) h))
          ;; Sum square height.
          (:fm:data (map-cell 0) (map-cell 1) 2
            (+ (:fm:data (map-cell 0) (map-cell 1) 2) (* h h)))
          )
        ()
        )
      )
    fm
    )
  )

#? (feature-map2cost-map <fm> <cm>)
;; Compute the cost map for the given feature map.
(de feature-map2cost-map (fm cm)
  ((-obj- (feature-map)) fm)
  ((-obj- (cost-map)) cm)
  (idx-bloop ((cell-r :fm:data) (cost-r :cm:data))
    (idx-bloop ((cell cell-r) (cost cost-r))
      ;; Store average height.
      (if (not (= 0 (cell 0)))
        (cost 0 (/ (cell 1) (cell 0)))
        ;; Else store infinite cost.
        (cost 0 :cm:inf-cost)
        )
      )
    )
  cm
  )

#? (render-depth-cost-frame <tb> <max-ht> <fm> <cm> <cm-rgb>)
;; Grab new depth data and render a single cost-map frame. The <max-ht> gives
;; the cost at which the display is saturated.
(de render-depth-cost-frame (tb max-cost fm cm cm-rgb)
  ;; Grab new depth data.
  (==> tb update-camera-depth-image-raw)
  (==> tb update-camera-depth-points)
  ;; Convert points to feature map.
  (xyz2feature-map :tb:camera-depth-points turtlebot-c2v fm)
  (feature-map2cost-map fm cm)
  ;; Convert cost-map to rgb.
  (idx-bloop ((cost-r :cm:data) (cost-rgb-r cm-rgb))
    (idx-bloop ((cost cost-r) (cost-rgb cost-rgb-r))
      (if (not (= :cm:inf-cost (cost 0)))
        ;; Shade of gray based on cost in range [-cost-map-max, cost-map-max].
        (let* ((color (min 255 (max 0 (* (/ (+ max-cost (cost 0)) (* max-cost 2)) 255)))))
          (idx-bloop ((rgb cost-rgb)) (rgb color))
          )
        ;; Else blue.
        (idx-copy [i 0 0 255] cost-rgb)
        )
      )
    )
  (gray-draw-matrix 0 0 :tb:camera-depth-image-raw 0 1023 1 1)
  (rgb-draw-matrix (idx-dim :tb:camera-depth-image-raw 1) 0 cm-rgb 2 2)
  )

#? (run-cost-map <tb> <n>)
;; Run and display cost map processing for turtlebot <tb> for <n> frames.
(de run-cost-map (tb n)
  ;; A valid turtlebot is required.
  (if (not tb)
    (print "Error : turtlebot is NULL")

    ;; Initialize streams (no harm to repeat this).
    (==> tb start-sub-camera-depth-image-raw)
    (==> tb start-sub-camera-depth-points)
    ;; Create feature, cost, and cost rgb maps.
    (let* ((fm (new feature-map [i 100 100] [f 0.02 0.02] 3))
           (cm (new cost-map fm))
           (cm-rgb (int-matrix (:cm:full-dim 0) (:cm:full-dim 1) 3)))
      ;; Create properly sized window if it doesn't exist.
      (if (not window) (
        let ((wnd-width 0)(wnd-height 0))
          (setq wnd-width (+ (idx-dim :tb:camera-depth-image-raw 1)
                             (* 2 (idx-dim cm-rgb 1))))
          (setq wnd-height (max (idx-dim :tb:camera-depth-image-raw 0)
                                (* 2 (idx-dim cm-rgb 0))))
          (new-window 0 0 wnd-width wnd-height)
          )
        )
      ;; Do n loops of cost map.
      (for (i 0 n) (render-depth-cost-frame tb 0.5 fm cm cm-rgb))
      )
    )
  ()
  )

;; Compile feature-map functions.
(dhc-make ()
  (feature-map
    feature-map
    world2map-cell
    in-bounds
    )
  (cost-map
    cost-map
    )
  vec3tformcoord
  xyz2feature-map
  feature-map2cost-map
  )

